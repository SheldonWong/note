(window.webpackJsonp=window.webpackJsonp||[]).push([[169],{596:function(e,a,t){"use strict";t.r(a);var s=t(44),r=Object(s.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"_05-每日面试题jquery"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_05-每日面试题jquery"}},[e._v("#")]),e._v(" 05 每日面试题JQuery")]),e._v(" "),t("h2",{attrs:{id:"_89-jquery-库中的-是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_89-jquery-库中的-是什么"}},[e._v("#")]),e._v(" 89.jQuery 库中的 $() 是什么？")]),e._v(" "),t("p",[e._v("$() 函数是 jQuery() 函数的别称,$() 函数用于将任何对象包裹成 jQuery 对象，接着你就被允许调用定义在 jQuery 对象上的多个不同方法。你甚至可以将一个选择器字符串传入 $() 函数，它会返回一个包含所有匹配的 DOM 元素数组的 jQuery 对象。")]),e._v(" "),t("h2",{attrs:{id:"_90-网页上有-5-个-元素-如何使用-jquery来选择它们"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_90-网页上有-5-个-元素-如何使用-jquery来选择它们"}},[e._v("#")]),e._v(" 90.网页上有 5 个 "),t("div",[e._v(" 元素，如何使用 jQuery来选择它们？")])]),e._v(" "),t("p",[e._v('$("div")，这样会返回一个包含所有 5 个 div 标签的 jQuery 对象。')]),e._v(" "),t("h2",{attrs:{id:"_91-jquery-里的-id-选择器和-class-选择器有何不同"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_91-jquery-里的-id-选择器和-class-选择器有何不同"}},[e._v("#")]),e._v(" 91. jQuery 里的 ID 选择器和 class 选择器有何不同？")]),e._v(" "),t("p",[e._v("ID 选择器使用 ID 来选择元素，比如 #element1，而 class 选择器使用 CSS class 来选择元素。当你只需要选择一个元素时，使用 ID 选择器，而如果你想要选择一组具有相同 CSS class 的元素，就要用 class 选择器。")]),e._v(" "),t("h2",{attrs:{id:"_92-如何在点击一个按钮时使用-jquery-隐藏一个图片"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_92-如何在点击一个按钮时使用-jquery-隐藏一个图片"}},[e._v("#")]),e._v(" 92. 如何在点击一个按钮时使用 jQuery 隐藏一个图片？")]),e._v(" "),t("p",[t("code",[e._v("$(``'#ButtonToClick'``).click(``function``(){")])]),e._v(" "),t("p",[t("code",[e._v("``$(``'#ImageToHide'``).hide();")])]),e._v(" "),t("p",[t("code",[e._v("});")])]),e._v(" "),t("h2",{attrs:{id:"_93-document-ready-是个什么函数-为什么要用它"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_93-document-ready-是个什么函数-为什么要用它"}},[e._v("#")]),e._v(" 93.$(document).ready() 是个什么函数？为什么要用它？")]),e._v(" "),t("p",[e._v("ready() 函数用于在文档进入ready状态时执行代码。当DOM 完全加载（例如HTML被完全解析DOM树构建完成时），jQuery允许你执行代码。使用$(document).ready()的最大好处在于它适用于所有浏览器，jQuery帮你解决了跨浏览器的难题。")]),e._v(" "),t("h2",{attrs:{id:"_94-javascript-window-onload-事件和-jquery-ready-函数有何不同"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_94-javascript-window-onload-事件和-jquery-ready-函数有何不同"}},[e._v("#")]),e._v(" 94.JavaScript window.onload 事件和 jQuery ready 函数有何不同？")]),e._v(" "),t("p",[e._v("JavaScript window.onload 事件和 jQuery ready 函数之间的主要区别是，前者除了要等待 DOM 被创建还要等到包括大型图片、音频、视频在内的所有外部资源都完全加载。如果加载图片和媒体内容花费了大量时间，用户就会感受到定义在 window.onload 事件上的代码在执行时有明显的延迟。")]),e._v(" "),t("p",[e._v("另一方面，jQuery ready() 函数只需对 DOM 树的等待，而无需对图像或外部资源加载的等待，从而执行起来更快。使用 jQuery $(document).ready() 的另一个优势是你可以在网页里多次使用它，浏览器会按它们在 HTML 页面里出现的顺序执行它们，相反对于 onload 技术而言，只能在单一函数里使用。鉴于这个好处，用 jQuery ready() 函数比用 JavaScript window.onload 事件要更好些。")]),e._v(" "),t("h2",{attrs:{id:"_95-this-和-this-关键字在-jquery-中有何不同"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_95-this-和-this-关键字在-jquery-中有何不同"}},[e._v("#")]),e._v(" 95.$(this) 和 this 关键字在 jQuery 中有何不同？")]),e._v(" "),t("p",[e._v("这对于很多 jQuery 初学者来说是一个棘手的问题，其实是个简单的问题。$(this) 返回一个 jQuery 对象，你可以对它调用多个 jQuery 方法，比如用 text() 获取文本，用val() 获取值等等。而 this 代表当前元素，它是 JavaScript 关键词中的一个，表示上下文中的当前 DOM 元素。你不能对它调用 jQuery 方法，直到它被 $() 函数包裹，例如 $(this)。")]),e._v(" "),t("h2",{attrs:{id:"_96-jquery中-detach-和-remove-方法的区别是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_96-jquery中-detach-和-remove-方法的区别是什么"}},[e._v("#")]),e._v(" 96.jQuery中 detach() 和 remove() 方法的区别是什么?")]),e._v(" "),t("p",[e._v("尽管 detach() 和 remove() 方法都被用来移除一个DOM元素, 两者之间的主要不同在于 detach() 会保持对过去被解除元素的跟踪, 因此它可以被取消解除, 而 remove() 方法则会保持过去被移除对象的引用. 你也还可以看看 用来向DOM中添加元素的 appendTo() 方法.")]),e._v(" "),t("h2",{attrs:{id:"_97-你如何利用jquery来向一个元素中添加和移除css类-答案"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_97-你如何利用jquery来向一个元素中添加和移除css类-答案"}},[e._v("#")]),e._v(" 97.你如何利用jQuery来向一个元素中添加和移除CSS类? (答案)")]),e._v(" "),t("p",[e._v('通过利用 addClass() 和 removeClass() 这两个 jQuery 方法。动态的改变元素的class属性可以很简单例如. 使用类“.active"来标记它们的未激活和激活状态，等等')]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('            .addClass("类名")添加元素      .remove()  删除样式类   \n')])])]),t("h2",{attrs:{id:"_98-jquery-get-和-jquery-ajax-方法之间的区别是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_98-jquery-get-和-jquery-ajax-方法之间的区别是什么"}},[e._v("#")]),e._v(" 98.jQuery.get() 和 jQuery.ajax() 方法之间的区别是什么?")]),e._v(" "),t("p",[e._v("ajax() 方法更强大，更具可配置性, 让你可以指定等待多久，以及如何处理错误。get() 方法是一个只获取一些数据的专门化方法。")]),e._v(" "),t("h2",{attrs:{id:"_99-jquery-中的方法链是什么-使用方法链有什么好处"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_99-jquery-中的方法链是什么-使用方法链有什么好处"}},[e._v("#")]),e._v(" 99.jQuery 中的方法链是什么？使用方法链有什么好处？")]),e._v(" "),t("p",[e._v("方法链是对一个方法返回的结果调用另一个方法，这使得代码简洁明了，同时由于只对 DOM 进行了一轮查找，性能方面更加出色。")]),e._v(" "),t("h2",{attrs:{id:"_100-如何用jquery禁用浏览器的前进后退按钮"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_100-如何用jquery禁用浏览器的前进后退按钮"}},[e._v("#")]),e._v(" 100.如何用jQuery禁用浏览器的前进后退按钮？")]),e._v(" "),t("p",[e._v("实现代码如下：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$(document).ready(function() {\n    window.history.forward(1);\n    //OR window.history.forward(-1);\n　　});\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br")])]),t("h2",{attrs:{id:"_101-jquery中-get-提交和-post-提交有区别吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_101-jquery中-get-提交和-post-提交有区别吗"}},[e._v("#")]),e._v(" 101. jquery中"),t("code",[e._v("$.get()")]),e._v("提交和"),t("code",[e._v("$.post()")]),e._v("提交有区别吗？")]),e._v(" "),t("ul",[t("li",[e._v("相同点：都是异步请求的方式来获取服务端的数据；")]),e._v(" "),t("li",[e._v("不同点：")])]),e._v(" "),t("ol",[t("li",[t("ol",[t("li",[e._v("请求方式不同："),t("code",[e._v("$.get()")]),e._v(" 方法使用GET方法来进行异步请求的。"),t("code",[e._v("$.post()")]),e._v(" 方法使用POST方法来进行异步请求的。")]),e._v(" "),t("li",[e._v("参数传递方式不同：get请求会将参数跟在URL后进行传递，而POST请求则是作为HTTP消息的实体内容发送给Web服务器的，这种传递是对用户不可见的。")]),e._v(" "),t("li",[e._v("数据传输大小不同：get方式传输的数据大小不能超过2KB 而POST要大的多")]),e._v(" "),t("li",[e._v("安全问题： GET 方式请求的数据会被浏览器缓存起来，因此有安全问题。")])])])]),e._v(" "),t("h2",{attrs:{id:"_102-写出一个简单的-ajax-的请求方式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_102-写出一个简单的-ajax-的请求方式"}},[e._v("#")]),e._v(" 102.写出一个简单的"),t("code",[e._v("$.ajax()")]),e._v("的请求方式？")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("$.ajax({\n    url:'http://www.baidu.com',\n    type:'POST',\n    data:data,\n    cache:true,\n    headers:{},\n    beforeSend：function(){},\n    success:function(){},\n    error:function(){},\n    complete:function(){}\n});\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br"),t("span",{staticClass:"line-number"},[e._v("8")]),t("br"),t("span",{staticClass:"line-number"},[e._v("9")]),t("br"),t("span",{staticClass:"line-number"},[e._v("10")]),t("br"),t("span",{staticClass:"line-number"},[e._v("11")]),t("br")])]),t("h2",{attrs:{id:"_103-为什么使用jquery"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_103-为什么使用jquery"}},[e._v("#")]),e._v(" 103.为什么使用jQuery")]),e._v(" "),t("p",[e._v("因为jQuery是轻量级的框架，它有强大的选择器，出色的DOM操作的封装，有可靠的事件处理机制，完善的ajax(它的ajax封装的非常的好，不需要考虑复杂浏览器的兼容性和XMLHttpRequest对象的创建和使用的问题) ,出色的浏览器的兼容性,而且支持链式操作，隐式迭代;行为层和结构层的分离，还支持丰富的插件，jquery的文档也非常的丰富。")]),e._v(" "),t("h2",{attrs:{id:"_104-你知道jquery中的选择器吗-请讲一下有哪些选择器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_104-你知道jquery中的选择器吗-请讲一下有哪些选择器"}},[e._v("#")]),e._v(" 104.你知道jquery中的选择器吗，请讲一下有哪些选择器？")]),e._v(" "),t("p",[e._v("选择器大致分为:基本选择器，层次选择器，过滤选择器，表单选择器")]),e._v(" "),t("h2",{attrs:{id:"_105-jquery中的选择器-和-css中的选择器有区别吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_105-jquery中的选择器-和-css中的选择器有区别吗"}},[e._v("#")]),e._v(" 105.jquery中的选择器 和 css中的选择器有区别吗？")]),e._v(" "),t("p",[e._v("jQuery选择器支持CSS里的选择器，jQuery选择器可用来添加样式和添加相应的行为，CSS 中的选择器是只能添加相应的样式。")]),e._v(" "),t("h2",{attrs:{id:"_106-你觉得jquery中的ajax好用吗-为什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_106-你觉得jquery中的ajax好用吗-为什么"}},[e._v("#")]),e._v(" 106.你觉得jquery中的ajax好用吗，为什么？")]),e._v(" "),t("p",[e._v("好用的。因为jQuery提供了一些日常开发中夙瑶的快捷操作，例 load，ajax，get，post等等，所以使用jQuery开发ajax将变得极其简单，我们就可以集中精力在业务和用户的体验上，不需要去理会那些繁琐的XMLHttpRequest对象了。ajax() 方法更强大，更具可配置性, 让你可以指定等待多久，以及如何处理错误。")]),e._v(" "),t("h2",{attrs:{id:"_107-你在jquery中使用过哪些插入节点的方法-它们的区别是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_107-你在jquery中使用过哪些插入节点的方法-它们的区别是什么"}},[e._v("#")]),e._v(" 107.你在jquery中使用过哪些插入节点的方法，它们的区别是什么？")]),e._v(" "),t("p",[e._v("答:append(),appendTo(),prepend(),prependTo(),after(),insertAfter() before(),insertBefore()")]),e._v(" "),t("p",[e._v("内添加")]),e._v(" "),t("p",[e._v("1.append在文档内添加元素")]),e._v(" "),t("p",[e._v("2.appendTo()把匹配的元素添加到对象里")]),e._v(" "),t("p",[e._v("3.prepend()在元素前添加")]),e._v(" "),t("p",[e._v("4.prependTo()把匹配的元素添加到对象前")]),e._v(" "),t("p",[e._v("外添加")]),e._v(" "),t("p",[e._v("1.after()在元素之后添加")]),e._v(" "),t("p",[e._v("2.before()在元素之前添加")]),e._v(" "),t("p",[e._v("3.insertAfter()把匹配元素在对象后添加")]),e._v(" "),t("p",[e._v("4.insertBefore()把匹配元素在对象前添加")]),e._v(" "),t("h2",{attrs:{id:"_108-jquery中有哪些方法可以遍历节点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_108-jquery中有哪些方法可以遍历节点"}},[e._v("#")]),e._v(" 108.jquery中有哪些方法可以遍历节点？")]),e._v(" "),t("p",[e._v("children() 取得匹配元素的子元素集合,只考虑子元素不考虑后代元素")]),e._v(" "),t("p",[e._v("next() 取得匹配元素后面紧邻的同辈元素")]),e._v(" "),t("p",[e._v("prev() 取得匹配元素前面紧邻的同辈元素")]),e._v(" "),t("p",[e._v("siblings() 取得匹配元素前后的所有同辈元素")]),e._v(" "),t("p",[e._v("closest() 取得最近的匹配元素")]),e._v(" "),t("p",[e._v("find() 取得匹配元素中的元素集合,包括子代和后代")]),e._v(" "),t("h2",{attrs:{id:"_109-jquery-能做什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_109-jquery-能做什么"}},[e._v("#")]),e._v(" 109.jQuery 能做什么？")]),e._v(" "),t("p",[e._v("1 获取页面的元素")]),e._v(" "),t("p",[e._v("2 修改页面的外观")]),e._v(" "),t("p",[e._v("3 改变页面大的内容")]),e._v(" "),t("p",[e._v("4 响应用户的页面操作")]),e._v(" "),t("p",[e._v("5 为页面添加动态效果")]),e._v(" "),t("p",[e._v("6 无需刷新页面，即可以从服务器获取信息")]),e._v(" "),t("p",[e._v("7 简化常见的javascript任务")]),e._v(" "),t("h2",{attrs:{id:"_110-jquery-里的-each-是什么函数-你是如何使用它的"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_110-jquery-里的-each-是什么函数-你是如何使用它的"}},[e._v("#")]),e._v(" 110.jQuery 里的 each() 是什么函数？你是如何使用它的？")]),e._v(" "),t("p",[e._v("each() 函数就像是 Java 里的一个 Iterator，它允许你遍历一个元素集合。你可以传一个函数给 each() 方法，被调用的 jQuery 对象会在其每个元素上执行传入的函数。")]),e._v(" "),t("h2",{attrs:{id:"_111-使用cdn加载-jquery库的主要优势是什么"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_111-使用cdn加载-jquery库的主要优势是什么"}},[e._v("#")]),e._v(" 111.使用CDN加载 jQuery库的主要优势是什么？")]),e._v(" "),t("p",[e._v("除了报错节省服务器带宽以及更快的下载速度这许多的好处之外, 最重要的是，如果浏览器已经从同一个CDN下载类相同的jQuery版本, 那么它就不会再去下载它一次，因此今时今日，许多公共的网站都将jQuery用于用户交互和动画, 如果浏览器已经有了下载好的jQuery库，网站就能有非常好的展示机会。")]),e._v(" "),t("h2",{attrs:{id:"_112-var-let-const的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_112-var-let-const的区别"}},[e._v("#")]),e._v(" 112.var,let,const的区别")]),e._v(" "),t("ul",[t("li",[e._v("使用 var 声明的变量，其作用域为全局作用域或者为所在的函数内局部作用域，且存在变量提升现象")]),e._v(" "),t("li",[e._v("使用 let 声明的变量，其作用域为该语句所在的代码块内{}，不存在变量提升")]),e._v(" "),t("li",[e._v("使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值")])]),e._v(" "),t("h2",{attrs:{id:"_113-es6的新语法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_113-es6的新语法"}},[e._v("#")]),e._v(" 113.ES6的新语法")]),e._v(" "),t("p",[e._v("\\1. let")]),e._v(" "),t("p",[e._v("let将会具有块级作用域，即在{}之间有效,同时不允许在为声明前进行使用")]),e._v(" "),t("p",[e._v("\\2. const")]),e._v(" "),t("p",[e._v("const为常量，不允许修改他的值")]),e._v(" "),t("p",[e._v("\\3. 模板字符串")]),e._v(" "),t("p",[e._v("\\4. 增强的对象字面量：【给对象属性赋值时，无需写成键值对】")]),e._v(" "),t("p",[e._v("\\5. 解构赋值")]),e._v(" "),t("p",[e._v("6."),t("strong",[e._v("es6之函数相关语法")])]),e._v(" "),t("p",[e._v("(1)函数参数默认值")]),e._v(" "),t("p",[e._v("(2) 函数不定参数")]),e._v(" "),t("p",[e._v("(3) 箭头函数")]),e._v(" "),t("p",[e._v("7."),t("strong",[e._v("es6之class相关语法")])]),e._v(" "),t("p",[e._v("**8.**"),t("strong",[e._v("es6之http请求相关语法")])]),e._v(" "),t("p",[e._v("(1.)promise的使用")]),e._v(" "),t("p",[e._v("(2.)fetch的使用")]),e._v(" "),t("p",[e._v("9."),t("strong",[e._v("es6之async-await相关语法")])]),e._v(" "),t("p",[t("strong",[e._v("等等")])]),e._v(" "),t("h2",{attrs:{id:"_114-说说你对数组的解构和对象的解构的理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_114-说说你对数组的解构和对象的解构的理解"}},[e._v("#")]),e._v(" 114.说说你对数组的解构和对象的解构的理解?")]),e._v(" "),t("h2",{attrs:{id:"_115-map和set的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_115-map和set的区别"}},[e._v("#")]),e._v(" 115.map和set的区别")]),e._v(" "),t("ul",[t("li",[e._v("map类似于对象，也是键值对的集合，但是“键”的范围不限制于字符串，各种类型的值（包含对象）都可以当作键。Map 也可以接受一个数组作为参数，数组的成员是一个个表示键值对的数组。注意Map里面也不可以放重复的项。")]),e._v(" "),t("li",[e._v("Set类似于数组，但是它里面每一项的值是唯一的，没有重复的值，Set是一个构造函数，用来生成set的数据结构")])]),e._v(" "),t("h2",{attrs:{id:"_116-set实现数组去重"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_116-set实现数组去重"}},[e._v("#")]),e._v(" 116.set实现数组去重")]),e._v(" "),t("p",[e._v("第一种数组去重方法（使用Array.from）：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let arr = [12,43,23,43,68,12];\nlet item = new Set(arr);\nconsole.log(item);//结果输出的是一个对象\n//使用Array.from转成数组\nlet arr = [12,43,23,43,68,12];\nlet item = Array.from(new Set(arr));\nconsole.log(item);// [12, 43, 23, 68]\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br"),t("span",{staticClass:"line-number"},[e._v("4")]),t("br"),t("span",{staticClass:"line-number"},[e._v("5")]),t("br"),t("span",{staticClass:"line-number"},[e._v("6")]),t("br"),t("span",{staticClass:"line-number"},[e._v("7")]),t("br")])]),t("p",[e._v("第二种数组去重方法（使用...扩展运算符）：")]),e._v(" "),t("div",{staticClass:"language- line-numbers-mode"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let arr = [12,43,23,43,68,12];\nlet item = [...new Set(arr)];\nconsole.log(item);//[12, 43, 23, 68]\n")])]),e._v(" "),t("div",{staticClass:"line-numbers-wrapper"},[t("span",{staticClass:"line-number"},[e._v("1")]),t("br"),t("span",{staticClass:"line-number"},[e._v("2")]),t("br"),t("span",{staticClass:"line-number"},[e._v("3")]),t("br")])]),t("h2",{attrs:{id:"_117-js的垃圾回收机制是什么-你得理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_117-js的垃圾回收机制是什么-你得理解"}},[e._v("#")]),e._v(" 117.JS的垃圾回收机制是什么?你得理解?")]),e._v(" "),t("p",[e._v("最常使用的方法叫做"),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Reference_counting",target:"_blank",rel:"noopener noreferrer"}},[e._v('"引用计数"'),t("OutboundLink")],1),e._v('（reference counting）：语言引擎有一张"引用表"，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是'),t("code",[e._v("0")]),e._v("，就表示这个值不再用到了，因此可以将这块内存释放。JS的垃圾回收机制是为了以防内存泄漏，垃圾回收机制就是间歇的不定期的寻找到不再使用的变量，并释放掉它们所指向的内存。")]),e._v(" "),t("h2",{attrs:{id:"_118-cookie、localstorage、sessionstorage的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_118-cookie、localstorage、sessionstorage的区别"}},[e._v("#")]),e._v(" 118.cookie、localStorage、sessionStorage的区别")]),e._v(" "),t("p",[e._v("\\1. cookie：能存储内容较小，在4k左右，一般用作保存用户登录状态、记住密码，记住账号使用。不清除的话会一直存在，可以设置过期时间自动清除，设置的时候可以设置在不同的域下面。每次在和服务端交互都会放在header里面，所以若是储存太多会影响性能。")]),e._v(" "),t("p",[e._v("2.localStorage：HTML5 标准中新加入的技术，可保存内容在5M左右，不会自动清除，除非手动进行删除。")]),e._v(" "),t("p",[e._v("\\3. sessionStorage：和localStorage类似，他们唯一区别就是sessionStorage保存在当前会话中，会话结束sessionStorage失效。会话一般是在关闭页面或者关闭浏览器失效。")]),e._v(" "),t("h2",{attrs:{id:"_119-前端性能优化相关理解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_119-前端性能优化相关理解"}},[e._v("#")]),e._v(" 119.前端性能优化相关理解")]),e._v(" "),t("p",[e._v("一般说来，web前端指网站业务逻辑之前的部分，包括浏览器加载、网站视图模型、图片服务、CDN服务等，主要优化手段有浏览器访问、使用反向代理才、CDN等。")]),e._v(" "),t("p",[e._v("1、减少http请求，合理浏览器缓存")]),e._v(" "),t("p",[e._v("2、启用压缩：HTML、CSS、javascript文件启用GZip压缩可达到较好的效果")]),e._v(" "),t("p",[e._v("3、CSS Sprites：合并 CSS图片，减少请求数的又一个好办法。")]),e._v(" "),t("p",[e._v("4、LazyLoad Images：在页面刚加载的时候可以只加载第一屏，当用户继续往后滚屏的时候才加载后续的图片")]),e._v(" "),t("p",[e._v("5、CSS放在页面最上部，javascript放在页面最下面：让浏览器尽快下载CSS渲染页面")]),e._v(" "),t("p",[e._v("6、异步请求Callback（就是将一些行为样式提取出来，慢慢的加载信息的内容）")]),e._v(" "),t("p",[e._v("7、Javascript代码优化")]),e._v(" "),t("p",[e._v("(1). DOM操作")]),e._v(" "),t("p",[e._v("a.HTML Collection（HTML收集器，返回的是一个数组内容信息）")]),e._v(" "),t("p",[e._v("在脚本中 document.images、document.forms、getElementsByTagName()返回的都是HTMLCollection类型的集合，在平时使用的时候大多将它作为数组来使用，因为它有 length属性，也可以使用索引访问每一个元素。不过在访问性能上则比数组要差很多，原因是这个集合并不是一个静态的结果，它表示的仅仅是一个特定的查询，每次访问该集合时都会重新执行这个查询从而更新查询结果。所谓的“访问集合” 包括读取集合的 length属性、访问集合中的元素。")]),e._v(" "),t("p",[e._v("因此，当你需要遍历 HTML Collection的时候，尽量将它转为数组后再访问，以提高性能。即使不转换为数组，也请尽可能少的访问它，例如在遍历的时候可以将 length属性、成员保存到局部变量后再使用局部变量。")]),e._v(" "),t("p",[e._v("b. 减少Reflow & Repaint")]),e._v(" "),t("p",[e._v("除了上面一点之外， DOM操作还需要考虑浏览器的Reflow和Repaint ，因为这些都是需要消耗资源的。")]),e._v(" "),t("p",[e._v("(3)避免使用 eval和 Function")]),e._v(" "),t("p",[e._v("每次 eval 或Function 构造函数作用于字符串表示的源代码时，脚本引擎都需要将源代码转换成可执行代码。这是很消耗资源的操作 —— 通常比简单的函数调用慢 100倍以上。")]),e._v(" "),t("p",[e._v("eval 函数效率特别低，由于事先无法知晓传给 eval 的字符串中的内容，eval在其上下文中解释要处理的代码，也就是说编译器无法优化上下文，因此只能有浏览器在运行时解释代码。这对性能影响很大。")]),e._v(" "),t("p",[e._v("Function 构造函数比 eval略好，因为使用此代码不会影响周围代码 ;但其速度仍很慢。")]),e._v(" "),t("p",[e._v("此外，使用 eval和 Function也不利于Javascript 压缩工具执行压缩。")]),e._v(" "),t("p",[e._v("(4) 减少作用域链查找")]),e._v(" "),t("p",[e._v("然后将拼接结果赋值给新变量。与之相比更为高效的做法是使用数组的 join方法，即将需要拼接的字符串放在数组中最后调用其 join方法得到结果。不过由于使用数组也有一定的开销，因此当需要拼接的字符串较多的时候可以考虑用此方法。")]),e._v(" "),t("p",[e._v("8、CSS选择符优化")]),e._v(" "),t("p",[e._v("在大多数人的观念中，都觉得浏览器对 CSS选择符的解析式从左往右进行的，例如")]),e._v(" "),t("p",[e._v("#toc A { color: #444; }这样一个选择符，如果是从右往左解析则效率会很高，因为第一个 ID选择基本上就把查找的范围限定了，但实际上浏览器对选择符的解析是从右往左进行的。如上面的选择符，浏览器必须遍历查找每一个 A标签的祖先节点，效率并不像之前想象的那样高。根据浏览器的这一行为特点，在写选择符的时候需要注意很多事项，有兴趣的童鞋可以去了解一下。")]),e._v(" "),t("p",[e._v("9.使用CDN（contentdistribute network，内容分发网络)")]),e._v(" "),t("h2",{attrs:{id:"_120-你能描述一下渐进增强和优雅降级之间的不同吗"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_120-你能描述一下渐进增强和优雅降级之间的不同吗"}},[e._v("#")]),e._v(" 120.你能描述一下渐进增强和优雅降级之间的不同吗?")]),e._v(" "),t("p",[e._v("**优雅降级：**Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会检查以确认它们是否能正常工作。由于IE独特的盒模型布局问题，针对不同版本的IE的hack实践过优雅降级了,为那些无法支持功能的浏览器增加候选方案，使之在旧式浏览器上以某种形式降级体验却不至于完全失效.")]),e._v(" "),t("p",[e._v("**渐进增强：**从被所有浏览器支持的基本功能开始，逐步地添加那些只有新式浏览器才支持的功能,向页面增加无害于基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。")]),e._v(" "),t("h1",{attrs:{id:"_121-settimeout、promise、async-await-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_121-settimeout、promise、async-await-的区别"}},[e._v("#")]),e._v(" 121."),t("a",{attrs:{href:"https://www.cnblogs.com/sugartang/p/11888854.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("setTimeout、Promise、Async/Await 的区别"),t("OutboundLink")],1)]),e._v(" "),t("h4",{attrs:{id:"_1-settimeout"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-settimeout"}},[e._v("#")]),e._v(" 1. setTimeout")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/gif/5375988/1612354310889-b946f7f3-e859-46bb-92c5-5331dc54b3e8.gif",alt:"image"}})]),e._v(" "),t("p",[e._v("console.log('script start')    //1. 打印 script start")]),e._v(" "),t("p",[e._v("setTimeout(function(){")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("console.log('settimeout')    // 4. 打印 settimeout\n")])])]),t("p",[e._v("})    // 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数")]),e._v(" "),t("p",[e._v("console.log('script end')    //3. 打印 script start")]),e._v(" "),t("p",[e._v("// 输出顺序：script start->script end->settimeout")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/gif/5375988/1612354310908-b8b857e3-3600-4f4f-bd37-50813f8e3282.gif",alt:"image"}})]),e._v(" "),t("h4",{attrs:{id:"_2-promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-promise"}},[e._v("#")]),e._v(" 2. Promise")]),e._v(" "),t("p",[e._v("Promise本身是"),t("strong",[e._v("同步的立即执行函数")]),e._v("， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then/catch等，当主栈完成后，才会去调用resolve/reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/gif/5375988/1612354310876-8241f435-bd9d-4179-92cf-55b804a7ddeb.gif",alt:"image"}})]),e._v(" "),t("p",[e._v("console.log('promise111')")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("    let promise1 = new Promise(function (resolve) {\n\n        console.log('promise222')\n\n        resolve()\n\n        console.log('promise333')\n\n    }).then(function () {\n\n        console.log('promise555')\n\n    })\n\n    setTimeout(function () {\n\n        console.log('promise666')\n\n    })\n\n    console.log('promise444')\n")])])]),t("p",[t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/gif/5375988/1612354310932-649f6091-05a6-4cb8-9c1a-e5677915eb59.gif",alt:"image"}})]),e._v(" "),t("p",[e._v("// 3. async/await")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://cdn.nlark.com/yuque/0/2021/gif/5375988/1612354310878-ed16107f-a6e6-4983-a209-0d9d9fa164b7.gif",alt:"image"}})]),e._v(" "),t("p",[e._v("async function async1() {")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("        console.log('async022');\n\n        await async2();\n\n        console.log('async055')\n\n    }\n\n    async function async2() {\n\n        console.log('async033')\n\n    }\n\n    console.log('async011');\n\n    async1();\n\n    console.log('async044')\n\n    // 输出顺序：script start->async1 start->async2->script end->async1 end\n\n    // async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。")])])])])}),[],!1,null,null,null);a.default=r.exports}}]);