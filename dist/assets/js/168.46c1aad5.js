(window.webpackJsonp=window.webpackJsonp||[]).push([[168],{585:function(t,_,v){"use strict";v.r(_);var a=v(44),s=Object(a.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"每日面试题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#每日面试题"}},[t._v("#")]),t._v(" 每日面试题")]),t._v(" "),v("h2",{attrs:{id:"_1-每个html文件里面都有一个很重要的东西-doctype-知道这是干什么的么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-每个html文件里面都有一个很重要的东西-doctype-知道这是干什么的么"}},[t._v("#")]),t._v(" 1."),v("strong",[t._v("每个HTML文件里面都有一个很重要的东西，Doctype，知道这是干什么的么？")])]),t._v(" "),v("p",[t._v("答：<!DOCTYPE>声明位于文档中最前面的位置，处于标签之前。此标签可告知浏览器文档使用哪种HTML或XHTML规范。（重点：告诉浏览器按照何种规范解析页面）")]),t._v(" "),v("h2",{attrs:{id:"_2-常用浏览器有哪些-内核都是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-常用浏览器有哪些-内核都是什么"}},[t._v("#")]),t._v(" 2."),v("strong",[t._v("常用浏览器有哪些，内核都是什么？")])]),t._v(" "),v("p",[v("strong",[t._v("答：")]),t._v(" 常用浏览器有chrome、safari、 IE、火狐(firefox) 、 Opera 、360、搜狗等")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("浏览器")]),t._v(" "),v("th",[t._v("内核")]),t._v(" "),v("th",[t._v("备注")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("IE")]),t._v(" "),v("td",[t._v("Trident")]),t._v(" "),v("td",[t._v("IE、猎豹安全、360极速浏览器、百度浏览器")])]),t._v(" "),v("tr",[v("td",[t._v("firefox")]),t._v(" "),v("td",[t._v("Gecko")]),t._v(" "),v("td",[t._v("可惜这几年已经没落了，打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。")])]),t._v(" "),v("tr",[v("td",[t._v("Safari")]),t._v(" "),v("td",[t._v("webkit")]),t._v(" "),v("td",[t._v("现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了）。苹果感觉像被别人抢了媳妇，都哭晕再厕所里面了。")])]),t._v(" "),v("tr",[v("td",[t._v("chrome")]),t._v(" "),v("td",[t._v("Chromium/Blink")]),t._v(" "),v("td",[t._v("在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。大部分国产浏览器最新版都采用Blink内核。二次开发")])]),t._v(" "),v("tr",[v("td",[t._v("Opera")]),t._v(" "),v("td",[t._v("blink")]),t._v(" "),v("td",[t._v("Presto（已经废弃） 是挪威产浏览器 opera 的 “前任” 内核,现在跟随chrome用blink内核。")])])])]),t._v(" "),v("h2",{attrs:{id:"_3-简述一下你对html语义化的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-简述一下你对html语义化的理解"}},[t._v("#")]),t._v(" 3."),v("strong",[t._v("简述一下你对HTML语义化的理解？")])]),t._v(" "),v("ol",[v("li",[t._v("去掉或丢失样式的时候能够让页面呈现出清晰的结构。")]),t._v(" "),v("li",[t._v("有利于SEO和搜索引擎建立良好沟通，有助于爬虫抓取更多的信息，爬虫依赖于标签来确定上下文和各个关键字的权重。")]),t._v(" "),v("li",[t._v("方便其它设备解析。")]),t._v(" "),v("li",[t._v("便于团队开发和维护，语义化根据可读性。")])]),t._v(" "),v("h2",{attrs:{id:"_4-html5有哪些新特性-移除了那些元素-如何处理html5新标签的浏览器兼容问题-如何区分html和html5"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-html5有哪些新特性-移除了那些元素-如何处理html5新标签的浏览器兼容问题-如何区分html和html5"}},[t._v("#")]),t._v(" 4."),v("strong",[t._v("HTML5有哪些新特性,移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分HTML和HTML5")]),t._v("？")]),t._v(" "),v("p",[t._v("答：新增加了图像、位置、存储、多任务等功能。")]),t._v(" "),v("p",[t._v("新增元素：")]),t._v(" "),v("ol",[v("li",[t._v("canvas")]),t._v(" "),v("li",[t._v("用于媒介回放的video和audio元素")]),t._v(" "),v("li",[t._v("本地离线存储。localStorage长期存储数据，浏览器关闭后数据不丢失;sessionStorage的数据在浏览器关闭后自动删除")]),t._v(" "),v("li",[t._v("语意化更好的内容元素，比如 article footer header nav section")]),t._v(" "),v("li",[t._v("位置API：Geolocation")]),t._v(" "),v("li",[t._v("表单控件，calendar date time email url search")]),t._v(" "),v("li",[t._v("新的技术：web worker(web worker是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行) web socket")]),t._v(" "),v("li",[t._v("拖放API：drag、drop")])]),t._v(" "),v("p",[t._v("移除的元素：")]),t._v(" "),v("ol",[v("li",[t._v("纯表现的元素：basefont big center font s strike tt u")]),t._v(" "),v("li",[t._v("性能较差元素：frame frameset noframes")])]),t._v(" "),v("p",[t._v("区分：")]),t._v(" "),v("ol",[v("li",[t._v("DOCTYPE声明的方式是区分重要因素")]),t._v(" "),v("li",[t._v("根据新增加的结构、功能来区分")])]),t._v(" "),v("h2",{attrs:{id:"_5-页面导入样式时-使用link和-import有什么区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-页面导入样式时-使用link和-import有什么区别"}},[t._v("#")]),t._v(" 5."),v("strong",[t._v("页面导入样式时，使用link和@import有什么区别？")])]),t._v(" "),v("p",[v("strong",[t._v("1.从属关系区别")])]),t._v(" "),v("p",[t._v("@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。")]),t._v(" "),v("p",[v("strong",[t._v("2.加载顺序区别")])]),t._v(" "),v("p",[t._v("加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。")]),t._v(" "),v("p",[v("strong",[t._v("3.兼容性区别")])]),t._v(" "),v("p",[t._v("@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题。")]),t._v(" "),v("p",[v("strong",[t._v("4.DOM可控性区别")])]),t._v(" "),v("p",[t._v("可以通过 JS 操作 DOM ，插入link标签来改变样式；由于 DOM 方法是基于文档的，无法使用@import的方式插入样式。")]),t._v(" "),v("p",[v("strong",[t._v("5.权重区别(该项有争议，下文将详解)")])]),t._v(" "),v("p",[t._v("link引入的样式权重大于@import引入的样式。")]),t._v(" "),v("h2",{attrs:{id:"_6-position属性和值的含义"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-position属性和值的含义"}},[t._v("#")]),t._v(" 6.position属性和值的含义")]),t._v(" "),v("p",[t._v("position 属性规定元素的定位类型。")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("值")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("absolute")]),t._v(" "),v("td",[t._v('生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。')])]),t._v(" "),v("tr",[v("td",[t._v("fixed")]),t._v(" "),v("td",[t._v('生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。')])]),t._v(" "),v("tr",[v("td",[t._v("relative")]),t._v(" "),v("td",[t._v('生成相对定位的元素，相对于其正常位置进行定位。因此，"left:20" 会向元素的 LEFT 位置添加 20 像素。')])]),t._v(" "),v("tr",[v("td",[t._v("static")]),t._v(" "),v("td",[t._v("默认值。没有定位，元素出现在正常的流中")])])])]),t._v(" "),v("h2",{attrs:{id:"_7-null-undefined的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-null-undefined的区别"}},[t._v("#")]),t._v(" 7.null，undefined的区别？")]),t._v(" "),v("ul",[v("li",[t._v("Undefined类型只有一个值，即undefined。当声明的变量还未被初始化时，变量的默认值为undefined。")]),t._v(" "),v("li",[t._v("Null类型也只有一个值，即null。")]),t._v(" "),v("li",[t._v("null是javascript的关键字，可以认为是对象类型，它是一个空对象指针，和其他语言一样都代表“空值”，不过undefined却是javascript才有的。undefined是在ECMAScript第三版引入的，为了区分指针对象和未初始化的变量，它是一个预定义的全局变量。没有返回值的函数返回为undefined，没有实参的形参也是undefined。")]),t._v(" "),v("li",[t._v("javascript权威指南：null 和 undefined 都表示 “值的空缺”，你可以认为 undefined 是表示系统级的、出乎意料的或类似错误的值的空缺，而null是表示程序级的、正常的或在意料之中的值的空缺。")]),t._v(" "),v("li",[t._v("javascript高级程序设计：在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined。null值则是表示空对象指针。")])]),t._v(" "),v("h2",{attrs:{id:"_8-添加-删除-替换-插入到某个接点的方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-添加-删除-替换-插入到某个接点的方法"}},[t._v("#")]),t._v(" 8.添加 删除 替换 插入到某个接点的方法？")]),t._v(" "),v("p",[t._v("1.创建新节点")]),t._v(" "),v("p",[t._v("createElement() //创建一个具体的元素")]),t._v(" "),v("p",[t._v("createTextNode() //创建一个文本节点")]),t._v(" "),v("p",[t._v("2.添加、移除、替换、插入")]),t._v(" "),v("p",[t._v("appendChild() //添加")]),t._v(" "),v("p",[t._v("removeChild() //移除")]),t._v(" "),v("p",[t._v("replaceChild() //替换")]),t._v(" "),v("p",[t._v("insertBefore() //插入")]),t._v(" "),v("p",[t._v("remove()//删除所有的子元素")]),t._v(" "),v("p",[t._v("3.查找")]),t._v(" "),v("p",[t._v("getElementsByTagName() //通过标签名称")]),t._v(" "),v("p",[t._v("getElementsByClassName() //通过元素的class属性的值")]),t._v(" "),v("p",[t._v("getElementById() //通过元素Id，唯一性")]),t._v(" "),v("h2",{attrs:{id:"_9-函数声明与函数表达式的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-函数声明与函数表达式的区别"}},[t._v("#")]),t._v(" 9.函数声明与函数表达式的区别？")]),t._v(" "),v("p",[t._v("在Javscript中，解析器在向执行环境中加载数据时，对函数声明和函数表达式并非是一视同仁的，解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问），至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解析执行。")]),t._v(" "),v("h2",{attrs:{id:"_10-new操作符具体干了什么呢"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-new操作符具体干了什么呢"}},[t._v("#")]),t._v(" 10.new操作符具体干了什么呢?")]),t._v(" "),v("ol",[v("li",[t._v("创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。")]),t._v(" "),v("li",[t._v("属性和方法被加入到 this 引用的对象中。")]),t._v(" "),v("li",[t._v("新创建的对象由 this 所引用，并且最后隐式的返回 this 。")])]),t._v(" "),v("h2",{attrs:{id:"_11-请说出至少三种减低页面加载时间的方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-请说出至少三种减低页面加载时间的方法"}},[t._v("#")]),t._v(" 11.请说出至少三种减低页面加载时间的方法？")]),t._v(" "),v("ol",[v("li",[t._v("压缩css、js文件")]),t._v(" "),v("li",[t._v("合并js、css文件，减少http请求")]),t._v(" "),v("li",[t._v("外部js、css文件放在最底下")]),t._v(" "),v("li",[t._v("减少dom操作，尽可能用变量替代不必要的dom操作")])]),t._v(" "),v("h2",{attrs:{id:"_12-讲几个常见的js内置对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-讲几个常见的js内置对象"}},[t._v("#")]),t._v(" 12.讲几个常见的js内置对象？")]),t._v(" "),v("p",[t._v("Object 是 JavaScript 中所有对象的父对象")]),t._v(" "),v("p",[t._v("数据封装类对象：Object、Array、Boolean、Number 和 String")]),t._v(" "),v("p",[t._v("其他对象：Function、Arguments、Math、Date、RegExp、Error")]),t._v(" "),v("h2",{attrs:{id:"_13-dom-事件流是什么-如何阻止事件冒泡"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-dom-事件流是什么-如何阻止事件冒泡"}},[t._v("#")]),t._v(" 13.DOM 事件流是什么?如何阻止事件冒泡？")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("事件流")]),t._v("：从页面中接收事件的顺序。也就是说当一个事件产生时，这个事件的传播过程，就是事件流。\n事件流包括三个阶段事件捕获,目标阶段,事件冒泡。")]),t._v(" "),v("li",[v("strong",[t._v("事件捕获")]),t._v("：它认为当某个事件发生时，从window发出一个事件，不断经过下级节点最终到达目标节点之前的阶段。（当某个事件发生时，父元素最先捕获到事件，目标元素最后收到）")]),t._v(" "),v("li",[v("strong",[t._v("目标阶段")]),t._v("：当事件不断传递直到目标节点的时候，最终在目标节点上出发这个事件。")]),t._v(" "),v("li",[v("strong",[t._v("事件冒泡")]),t._v("：事件冒泡即事件开始时，由最具体的元素接收（也就是事件发生所在的节点），然后层层往上传递，直至传递到dom的根节点。")]),t._v(" "),v("li",[t._v("阻止事件冒泡:event.stopPropagation()")])]),t._v(" "),v("h2",{attrs:{id:"_14-什么是事件委托"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-什么是事件委托"}},[t._v("#")]),t._v(" 14.什么是事件委托?")]),t._v(" "),v("p",[t._v("利用事件冒泡的原理，原本绑定在子元素身上的事件，现在绑定在父元素身上，由父元素监听事件的行为。")]),t._v(" "),v("h2",{attrs:{id:"_15-说一下你对this的理解"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_15-说一下你对this的理解"}},[t._v("#")]),t._v(" 15.说一下你对this的理解？")]),t._v(" "),v("p",[t._v("this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了this 的指向不同")]),t._v(" "),v("ol",[v("li",[t._v("普通函数this在非严格模式下指向window，严格模式下指向undefined")]),t._v(" "),v("li",[t._v("构造函数this指向实例对象，原型对象里面的方法也指向实例对象")]),t._v(" "),v("li",[t._v("对象方法中的this指向该方法所属的对象")]),t._v(" "),v("li",[t._v("事件绑定方法中的this指向绑定该事件的对象")]),t._v(" "),v("li",[t._v("定时器函数的this指向window")]),t._v(" "),v("li",[t._v("立即执行函数中的this指向window")])]),t._v(" "),v("h2",{attrs:{id:"_16-什么是作用域和作用域链-js有几种作用域分别是"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_16-什么是作用域和作用域链-js有几种作用域分别是"}},[t._v("#")]),t._v(" 16.什么是作用域和作用域链，js有几种作用域分别是？")]),t._v(" "),v("h2",{attrs:{id:"作用域-scope"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作用域-scope"}},[t._v("#")]),t._v(" "),v("strong",[t._v("作用域（scope）")])]),t._v(" "),v("p",[t._v("作用域是指程序源代码中定义变量的区域，简单来说，一段程序代码中所用到的变量并不总是有效的，而限定这个变量的可用性的代码范围就是这个变量的作用域。")]),t._v(" "),v("p",[t._v("js有三种:")]),t._v(" "),v("ul",[v("li",[t._v("全局作用域\n全局作用域是最外围的一个作用域。根据 ECMAScript 实现所在的宿主环境不同，表示全局作用域的对象也不一样。在浏览器中，全局作用域就是window对象，node则是global对象。")]),t._v(" "),v("li",[t._v("局部作用域\n和全局作用域相反，局部作用域一般只在固定的代码片段内可访问到，最常见的是函数内部。")]),t._v(" "),v("li",[t._v("块级作用域\nES5本身是没有块级作用域，ES6 引入了块级作用域，让变量的生命周期更加可控，使用let和const声明的变量在指定块（简单理解就是一对花括号）的作用域外无法被访问。")])]),t._v(" "),v("h2",{attrs:{id:"作用域链-scope-chain"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#作用域链-scope-chain"}},[t._v("#")]),t._v(" "),v("strong",[t._v("作用域链（scope chain）")])]),t._v(" "),v("p",[t._v("一般情况下，变量取值到创建这个变量的函数的作用域中取值。但是如果在当前作用域中没有查到值，就会向上级作用域去查，直到查到全局作用域，这么一个查找过程形成的链条就叫做作用域链。")]),t._v(" "),v("h2",{attrs:{id:"_17-javascript的事件流模型都有什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_17-javascript的事件流模型都有什么"}},[t._v("#")]),t._v(" 17.Javascript的事件流模型都有什么?")]),t._v(" "),v("p",[t._v("“DOM事件流”：三个阶段：事件捕捉，目标阶段，事件冒泡。")]),t._v(" "),v("p",[t._v("JS事件流最早要从IE和网景公司的浏览器大战说起，IE提出的是冒泡流，而网景提出的是捕获流，后来在W3C组织的统一之下，JS支持了冒泡流和捕获流，但是目前低版本的IE浏览器还是只能支持冒泡流(IE6,IE7,IE8均只支持冒泡流)，所以为了能够兼容更多的浏览器，建议大家使用冒泡流。")]),t._v(" "),v("h2",{attrs:{id:"_18-简述window对象除-document以外的一些常用子对象-并描述其作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_18-简述window对象除-document以外的一些常用子对象-并描述其作用"}},[t._v("#")]),t._v(" 18.简述window对象除 document以外的一些常用子对象，并描述其作用？")]),t._v(" "),v("p",[t._v("window对象有很多子对象，除了 document以外，还有如下常用子对象：")]),t._v(" "),v("ul",[v("li",[t._v("screen对象：此对象包含有关客户端显示屏幕的信息，常用于获取屏幕的分\n辨率和色彩；")]),t._v(" "),v("li",[t._v("history对象：此对象包含用户（在浏览器窗口中）访问过的 URL；")]),t._v(" "),v("li",[t._v("location对象：此对象包含有关当前 URL的信息，常用于获取和改变当前浏览的网址；")]),t._v(" "),v("li",[t._v("navigator对象：此对象包含有关浏览器的信息，常用于获取客户端浏览器和操作系统信息；")]),t._v(" "),v("li",[t._v("event对象：任何事件触发后将会产生一个 event对象，该对象记录事件发\n生时的鼠标位置、键盘按键状态和触发对象等信息。")])]),t._v(" "),v("h2",{attrs:{id:"_19-bom-和-dom-的关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_19-bom-和-dom-的关系"}},[t._v("#")]),t._v(" 19.BOM 和 DOM 的关系")]),t._v(" "),v("p",[t._v("BOM全称Browser Object Model，即浏览器对象模型，主要处理浏览器窗口和框架。")]),t._v(" "),v("p",[t._v("DOM全称Document Object Model，即文档对象模型，是 HTML 和XML 的应用程序接口（API），遵循W3C 的标准，所有浏览器公共遵守的标准。")]),t._v(" "),v("p",[t._v("JS是通过访问BOM（Browser Object Model）对象来访问、控制、修改客户端(浏览器)，由于BOM的window包含了document，window对象的属性和方法是直接可以使用而且被感知的，因此可以直接使用window对象的document属性，通过document属性就可以访问、检索、修改XHTML文档内容与结构。因为document对象又是DOM的根节点。")]),t._v(" "),v("p",[t._v("可以说，BOM包含了DOM(对象)，浏览器提供出来给予访问的是BOM对象，从BOM对象再访问到DOM对象，从而js可以操作浏览器以及浏览器读取到的文档。")]),t._v(" "),v("h2",{attrs:{id:"_20-请说出你熟悉的数组的操作方法并说出如何使用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_20-请说出你熟悉的数组的操作方法并说出如何使用"}},[t._v("#")]),t._v(" 20.请说出你熟悉的数组的操作方法并说出如何使用?")]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("//改变原数组方法:\nvar arr = []\narr.push()  //数组末尾添加\narr.pop()   //数组末尾删除\narr.unshift()  //数组头部添加\narr.shift()         //数组头部删除\narr.splice()        //方法向/从数组中添加/删除项目，然后返回被删除的项目。\narr.reverse()       //方法用于颠倒数组中元素的顺序。\narr.sort()          //方法用于对数组的元素进行排序。\n//不改变原数组方法:\nvar arr = []\narr.includes();  // 方法用于判断字符串是否包含指定的子字符串。如果找到匹配的字符串则返回 true，否则返回 false。\narr.indexOf();      //方法可返回某个指定的字符串值在字符串中首次出现的位置。\narr.lastIndexOf();  //方法可返回一个指定的字符串值最后出现的位置，在一个字符串中的指定位置从后向前搜索。\narr.slice();            //方法可从已有的数组中返回选定的元素。\narr.join();             //方法用于把数组中的所有元素放入一个字符串。元素是通过指定的分隔符进行分隔的。\narr.toString(); \narr.concat();       //方法用于连接两个或多个数组。\n\n//高阶js新增数组方法\n\narr.forEach//遍历数组\n\n//数组方法filter过滤数组\nfilter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。\n\n\n//数组方法some\narr.some()// 查找数组中是否有满足条件的元素 ,如果数组中有元素满足条件返回 true，否则返回 false。\n\n//数组方法every\nevery() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。\nevery() 方法使用指定函数检测数组中的所有元素：\narray.every(function(currentValue,index,arr))\n- 如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。\n- 如果所有元素都满足条件，则返回 true。\n  注意： every() 不会对空数组进行检测。\n  注意： every() 不会改变原始数组。\n\n  \n//数组方法find\nfind() 方法返回通过测试（函数内判断）的数组的第一个元素的值。\nfind() 方法为数组中的每个元素都调用一次函数执行：\n- 当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。\n- 如果没有符合条件的元素返回 undefined\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br"),v("span",{staticClass:"line-number"},[t._v("7")]),v("br"),v("span",{staticClass:"line-number"},[t._v("8")]),v("br"),v("span",{staticClass:"line-number"},[t._v("9")]),v("br"),v("span",{staticClass:"line-number"},[t._v("10")]),v("br"),v("span",{staticClass:"line-number"},[t._v("11")]),v("br"),v("span",{staticClass:"line-number"},[t._v("12")]),v("br"),v("span",{staticClass:"line-number"},[t._v("13")]),v("br"),v("span",{staticClass:"line-number"},[t._v("14")]),v("br"),v("span",{staticClass:"line-number"},[t._v("15")]),v("br"),v("span",{staticClass:"line-number"},[t._v("16")]),v("br"),v("span",{staticClass:"line-number"},[t._v("17")]),v("br"),v("span",{staticClass:"line-number"},[t._v("18")]),v("br"),v("span",{staticClass:"line-number"},[t._v("19")]),v("br"),v("span",{staticClass:"line-number"},[t._v("20")]),v("br"),v("span",{staticClass:"line-number"},[t._v("21")]),v("br"),v("span",{staticClass:"line-number"},[t._v("22")]),v("br"),v("span",{staticClass:"line-number"},[t._v("23")]),v("br"),v("span",{staticClass:"line-number"},[t._v("24")]),v("br"),v("span",{staticClass:"line-number"},[t._v("25")]),v("br"),v("span",{staticClass:"line-number"},[t._v("26")]),v("br"),v("span",{staticClass:"line-number"},[t._v("27")]),v("br"),v("span",{staticClass:"line-number"},[t._v("28")]),v("br"),v("span",{staticClass:"line-number"},[t._v("29")]),v("br"),v("span",{staticClass:"line-number"},[t._v("30")]),v("br"),v("span",{staticClass:"line-number"},[t._v("31")]),v("br"),v("span",{staticClass:"line-number"},[t._v("32")]),v("br"),v("span",{staticClass:"line-number"},[t._v("33")]),v("br"),v("span",{staticClass:"line-number"},[t._v("34")]),v("br"),v("span",{staticClass:"line-number"},[t._v("35")]),v("br"),v("span",{staticClass:"line-number"},[t._v("36")]),v("br"),v("span",{staticClass:"line-number"},[t._v("37")]),v("br"),v("span",{staticClass:"line-number"},[t._v("38")]),v("br"),v("span",{staticClass:"line-number"},[t._v("39")]),v("br"),v("span",{staticClass:"line-number"},[t._v("40")]),v("br"),v("span",{staticClass:"line-number"},[t._v("41")]),v("br"),v("span",{staticClass:"line-number"},[t._v("42")]),v("br"),v("span",{staticClass:"line-number"},[t._v("43")]),v("br"),v("span",{staticClass:"line-number"},[t._v("44")]),v("br"),v("span",{staticClass:"line-number"},[t._v("45")]),v("br")])]),v("h2",{attrs:{id:"_21-总结string-对象操作方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_21-总结string-对象操作方法"}},[t._v("#")]),t._v(" 21.总结String 对象操作方法")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("方法")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("charAt()")]),t._v(" "),v("td",[t._v("返回在指定位置的字符。")])]),t._v(" "),v("tr",[v("td",[t._v("charCodeAt()")]),t._v(" "),v("td",[t._v("返回在指定的位置的字符的 Unicode 编码。")])]),t._v(" "),v("tr",[v("td",[t._v("concat()")]),t._v(" "),v("td",[t._v("连接两个或更多字符串，并返回新的字符串。")])]),t._v(" "),v("tr",[v("td",[t._v("fromCharCode()")]),t._v(" "),v("td",[t._v("将 Unicode 编码转为字符。")])]),t._v(" "),v("tr",[v("td",[t._v("indexOf()")]),t._v(" "),v("td",[t._v("返回某个指定的字符串值在字符串中首次出现的位置。")])]),t._v(" "),v("tr",[v("td",[t._v("includes()")]),t._v(" "),v("td",[t._v("查找字符串中是否包含指定的子字符串。")])]),t._v(" "),v("tr",[v("td",[t._v("lastIndexOf()")]),t._v(" "),v("td",[t._v("从后向前搜索字符串，并从起始位置（0）开始计算返回字符串最后出现的位置。")])]),t._v(" "),v("tr",[v("td",[t._v("search()")]),t._v(" "),v("td",[t._v("查找与正则表达式相匹配的值。")])]),t._v(" "),v("tr",[v("td",[t._v("slice()")]),t._v(" "),v("td",[t._v("提取字符串的片断，并在新的字符串中返回被提取的部分。不包含结束的索引")])]),t._v(" "),v("tr",[v("td",[t._v("split()")]),t._v(" "),v("td",[t._v("把字符串分割为字符串数组。")])]),t._v(" "),v("tr",[v("td",[t._v("substr()")]),t._v(" "),v("td",[t._v("从起始索引号提取字符串中指定数目的字符。")])]),t._v(" "),v("tr",[v("td",[t._v("substring()")]),t._v(" "),v("td",[t._v("提取字符串中两个指定的索引号之间的字符。")])]),t._v(" "),v("tr",[v("td",[t._v("toLowerCase()")]),t._v(" "),v("td",[t._v("把字符串转换为小写。")])]),t._v(" "),v("tr",[v("td",[t._v("toUpperCase()")]),t._v(" "),v("td",[t._v("把字符串转换为大写。")])]),t._v(" "),v("tr",[v("td",[t._v("trim()")]),t._v(" "),v("td",[t._v("去除字符串两边的空白")])]),t._v(" "),v("tr",[v("td",[t._v("toString()")]),t._v(" "),v("td",[t._v("返回一个字符串。")])])])]),t._v(" "),v("h2",{attrs:{id:"_22-如何编写高性能的javascript"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_22-如何编写高性能的javascript"}},[t._v("#")]),t._v(" 22.如何编写高性能的JavaScript")]),t._v(" "),v("ul",[v("li",[t._v("将js脚本放在页面底部，加快渲染页面;")]),t._v(" "),v("li",[t._v("将js脚本成组打包，减少请求;")]),t._v(" "),v("li",[t._v("使用非阻塞方式下载js脚本;")]),t._v(" "),v("li",[t._v("尽量使用局部变量来保存全局变量;")]),t._v(" "),v("li",[t._v("尽量减少使用闭包;")]),t._v(" "),v("li",[t._v("使用window对象属性方法时省略window;")]),t._v(" "),v("li",[t._v("尽量减少对象成员嵌套;")]),t._v(" "),v("li",[t._v("缓存DOM节点的访问;")]),t._v(" "),v("li",[t._v("通过避免使用eval和function()构造器;")]),t._v(" "),v("li",[t._v("给setTimeout()和setInterval()传递函数而不是字符作为参数;")]),t._v(" "),v("li",[t._v("尽量使用直接量创建对象和数组;")]),t._v(" "),v("li",[t._v("最小化重绘(repaint)和回流(reflow);")])]),t._v(" "),v("h2",{attrs:{id:"_23-标准盒模型-和ie盒模型区别-复习css知识等"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_23-标准盒模型-和ie盒模型区别-复习css知识等"}},[t._v("#")]),t._v(" 23.标准盒模型 和ie盒模型区别(复习CSS知识等)")]),t._v(" "),v("p",[t._v("标准盒模型是w3c 标准的盒模型，其包含：")]),t._v(" "),v("p",[t._v("盒子占用宽度：margin + border+ padding + width")]),t._v(" "),v("p",[t._v("实际宽度： border+ padding + width")]),t._v(" "),v("p",[t._v("IE盒模型，在IE中content的宽度包括padding和border这两个属性，所以")]),t._v(" "),v("p",[t._v("盒子占用宽度：margin + width")]),t._v(" "),v("p",[t._v("实际宽度：width = padding + border + "),v("strong",[t._v("内容宽度")])]),t._v(" "),v("h2",{attrs:{id:"_24-浏览器是如何渲染页面的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_24-浏览器是如何渲染页面的"}},[t._v("#")]),t._v(" 24.浏览器是如何渲染页面的？")]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("渲染的流程如下:\n解析HTML文件，创建DOM树。\n自上而下，遇到任何样式（link、style）与脚本（script）都会阻塞（外部样式不阻塞后续外部脚本的加载）。\n解析CSS。优先级：浏览器默认设置<用户设置<外部样式<内联样式<HTML中的style样式。\n将CSS与DOM合并，构建渲染树（Render Tree）。\n布局和绘制，重绘（repaint）和重排（reflow）。\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br")])]),v("p",[t._v("参考资料:"),v("a",{attrs:{href:"https://www.cnblogs.com/echolun/p/10105223.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("https://www.cnblogs.com/echolun/p/10105223.html"),v("OutboundLink")],1)]),t._v(" "),v("h2",{attrs:{id:"_25-全局变量和局部变量的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_25-全局变量和局部变量的区别"}},[t._v("#")]),t._v(" 25.全局变量和局部变量的区别？")]),t._v(" "),v("p",[t._v("变量根据作用域的不同分为两种：全局变量和局部变量。")]),t._v(" "),v("ol",[v("li",[t._v("函数内部可以使用全局变量。")]),t._v(" "),v("li",[t._v("函数外部不可以使用局部变量。")]),t._v(" "),v("li",[t._v("当函数执行完毕，本作用域内的局部变量会销毁。")]),t._v(" "),v("li",[t._v("网页关闭时,全局变量销毁。")])]),t._v(" "),v("h2",{attrs:{id:"_26-栈结构和队列结构-这两种数据结构的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_26-栈结构和队列结构-这两种数据结构的区别"}},[t._v("#")]),t._v(" 26.栈结构和队列结构,这两种数据结构的区别?")]),t._v(" "),v("p",[t._v("栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。")]),t._v(" "),v("p",[t._v("队列先进先出，栈先进后出。")]),t._v(" "),v("p",[t._v("栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除")]),t._v(" "),v("h2",{attrs:{id:"_27-栈区和堆区的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_27-栈区和堆区的区别"}},[t._v("#")]),t._v(" 27.栈区和堆区的区别？")]),t._v(" "),v("p",[t._v("栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。")]),t._v(" "),v("p",[t._v("堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。")]),t._v(" "),v("p",[t._v("堆（数据结构）：堆可以被看成是一棵树，如：堆排序；")]),t._v(" "),v("p",[t._v("栈（数据结构）：一种先进后出的数据结构")]),t._v(" "),v("h2",{attrs:{id:"_28-flex属性举例说明"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_28-flex属性举例说明"}},[t._v("#")]),t._v(" 28.flex属性举例说明")]),t._v(" "),v("h2",{attrs:{id:"父元素属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#父元素属性"}},[t._v("#")]),t._v(" "),v("strong",[t._v("父元素属性")])]),t._v(" "),v("p",[t._v("1.display:flex;（定义了一个flex容器）")]),t._v(" "),v("p",[t._v("2.flex-direction（决定主轴的方向）")]),t._v(" "),v("p",[t._v("row（默认值，水平从左到右）colunm（垂直从上到下）row-reverse（水平从右到左）column-reverse（垂直从下到上）")]),t._v(" "),v("p",[t._v("3.flex-wrap（定义如何换行）")]),t._v(" "),v("p",[t._v("nowrap（默认值，不换行）wrap（换行）wrap-reverse（换行，且颠倒行顺序，第一行在下方）")]),t._v(" "),v("p",[t._v("4.flex-flow（属性是 flex-direction 属性和 flex-wrap 属性的简写形式，默认值为row nowrap）")]),t._v(" "),v("p",[t._v("5.justify-content（设置或检索弹性盒子元素在主轴（横轴）方向上的对齐方式）")]),t._v(" "),v("p",[t._v("flex-start（ 默认值、弹性盒子元素将向行起始位置对齐）")]),t._v(" "),v("p",[t._v("flex-end（弹性盒子元素将向行结束位置对齐）")]),t._v(" "),v("p",[t._v("center（弹性盒子元素将向行中间位置对齐。该行的子元素将相互对齐并在行中居中对齐）")]),t._v(" "),v("p",[t._v("space-between（弹性盒子元素会平均地分布在行里）")]),t._v(" "),v("p",[t._v("space-around（弹性盒子元素会平均地分布在行里，两端保留子元素与子元素之间间距大小的一半）")]),t._v(" "),v("p",[t._v("6.align-items（设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式）")]),t._v(" "),v("p",[t._v("flex-start（弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴起始边界）")]),t._v(" "),v("p",[t._v("flex-end（弹性盒子元素的侧轴（纵轴）起始位置的边界紧靠住该行的侧轴结束边界）")]),t._v(" "),v("p",[t._v("center（ 弹性盒子元素在该行的侧轴（纵轴）上居中放置。（如果该行的尺寸小于弹性盒子元素的尺寸，则会向两个方向溢出相同的长度））")]),t._v(" "),v("p",[t._v("baseline（如弹性盒子元素的行内轴与侧轴为同一条，则该值与flex-start等效。其它情况下，该值将参与基线对齐。）")]),t._v(" "),v("p",[t._v("stretch（如果指定侧轴大小的属性值为'auto'，则其值会使项目的边距盒的尺寸尽可能接近所在行的尺寸，但同时会遵照'min/max-width/height'属性的限制）")]),t._v(" "),v("p",[t._v("7.align-content（设置或检索弹性盒堆叠伸缩行的对齐方式）")]),t._v(" "),v("p",[t._v("flex-start（各行向弹性盒容器的起始位置堆叠。弹性盒容器中第一行的侧轴起始边界紧靠住该弹性盒容器的侧轴起始边界，之后的每一行都紧靠住前面一行）")]),t._v(" "),v("p",[t._v("flex-end（各行向弹性盒容器的结束位置堆叠。弹性盒容器中最后一行的侧轴起结束界紧靠住该弹性盒容器的侧轴结束边界，之后的每一行都紧靠住前面一行）")]),t._v(" "),v("p",[t._v("center（各行向弹性盒容器的中间位置堆叠。各行两两紧靠住同时在弹性盒容器中居中对齐，保持弹性盒容器的侧轴起始内容边界和第一行之间的距离与该容器的侧轴结束内容边界与第最后一      行之间的距离相等）")]),t._v(" "),v("p",[t._v("space-between（各行在弹性盒容器中平均分布。第一行的侧轴起始边界紧靠住弹性盒容器的侧轴起始内容边界，最后一行的侧轴结束边界紧靠住弹性盒容器的侧轴结束内容边界，剩余的行则      按一定方式在弹性盒窗口中排列，以保持两两之间的空间相等）")]),t._v(" "),v("p",[t._v("space-around（ 各行在弹性盒容器中平均分布，两端保留子元素与子元素之间间距大小的一半。各行会按一定方式在弹性盒容器中排列，以保持两两之间的空间相等，同时第一行前面及最后      一行后面的空间是其他空间的一半）")]),t._v(" "),v("p",[t._v("stretch（各行将会伸展以占用剩余的空间。剩余空间被所有行平分，以扩大它们的侧轴尺寸）")]),t._v(" "),v("h2",{attrs:{id:"子元素上属性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#子元素上属性"}},[t._v("#")]),t._v(" "),v("strong",[t._v("子元素上属性")])]),t._v(" "),v("p",[t._v("1.order（默认情况下flex order会按照书写顺训呈现，可以通过order属性改变，数值小的在前面，还可以是负数）")]),t._v(" "),v("p",[t._v("2.flex-grow（设置或检索弹性盒的扩展比率,根据弹性盒子元素所设置的扩展因子作为比率来分配剩余空间）")]),t._v(" "),v("p",[t._v("3.flex-shrink（设置或检索弹性盒的收缩比率,根据弹性盒子元素所设置的收缩因子作为比率来收缩空间）")]),t._v(" "),v("p",[t._v("4.flex-basis (设置或检索弹性盒伸缩基准值，如果所有子元素的基准值之和大于剩余空间，则会根据每项设置的基准值，按比率伸缩剩余空间)")]),t._v(" "),v("p",[t._v("5.flex   (flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选)")]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("//flex属性意义\nflex:none;   // flex:0,0,auto;\nflex:auto;  // flex:1,1,auto;\nflex:1;    //  flex:1,1,0%;\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br")])]),v("p",[t._v("6.align-self  (设置或检索弹性盒子元素在侧轴（纵轴）方向上的对齐方式，可以覆盖父容器align-items的设置)")]),t._v(" "),v("h2",{attrs:{id:"_29-你用过媒体查询-或针对移动端的布局-css吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_29-你用过媒体查询-或针对移动端的布局-css吗"}},[t._v("#")]),t._v(" 29.你用过媒体查询，或针对移动端的布局/CSS吗？")]),t._v(" "),v("p",[t._v("媒体查询，就是响应式布局。通过不同的媒介类型和条件定义样式表规则。媒介查询让CSS可以更精确作用于不同的媒介类型和同一媒介的不同条件。")]),t._v(" "),v("p",[t._v("语法结构及用法："),v("a",{attrs:{href:"https://www.yuque.com/media",target:"_blank",rel:"noopener noreferrer"}},[t._v("@media "),v("OutboundLink")],1),t._v(" 设备名 only （选取条件） not （选取条件） and（设备选取条件）。")]),t._v(" "),v("h2",{attrs:{id:"_30-href与src的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_30-href与src的区别"}},[t._v("#")]),t._v(" 30.href与src的区别")]),t._v(" "),v("p",[t._v("1.href：Hypertext Reference的缩写，超文本引用，它指向一些网络资源，建立和当前元素或者说是本文档的链接关系。在加载它的时候，不会停止对当前文档的处理，浏览器会继续往下走。常用在a、link等标签。")]),t._v(" "),v("p",[t._v("2.src：source的所写，表示的是对资源的引用，它指向的内容会嵌入到当前标签所在的位置。由于src的内容是页面必不可少的一部分，因此浏览器在解析src时会停下来对后续文档的处理，直到src的内容加载完毕。常用在script、img、iframe标签中，我们建议js文件放在HTML文档的最后面。如果js文件放在了head标签中，可以使用window.onload实现js的最后加载。")]),t._v(" "),v("p",[t._v("总结：href用于建立当前页面与引用资源之间的关系（链接），而src则会替换当前标签。遇到href，页面会并行加载后续内容；而src则不同，浏览器需要加载完毕src的内容才会继续往下走。")]),t._v(" "),v("h2",{attrs:{id:"_31-说一说事件代理-优缺点是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_31-说一说事件代理-优缺点是什么"}},[t._v("#")]),t._v(" 31.说一说事件代理,优缺点是什么?")]),t._v(" "),v("p",[t._v("事件代理是指将事件绑定到目标元素的父元素上,利用冒泡机制触发该事件")]),t._v(" "),v("p",[t._v("优点:")]),t._v(" "),v("p",[t._v("1.可以减少事件注册,节省大量内存占用")]),t._v(" "),v("p",[t._v("2.可以将事件应用于动态添加的子元素上")]),t._v(" "),v("p",[t._v("缺点:")]),t._v(" "),v("p",[t._v("使用不当会造成事件在不应该触发时触发")]),t._v(" "),v("h2",{attrs:{id:"_32-简单数据类型和复杂数据类型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_32-简单数据类型和复杂数据类型"}},[t._v("#")]),t._v(" 32.简单数据类型和复杂数据类型")]),t._v(" "),v("p",[t._v("简单类型（基本数据类型、值类型）：在存储时变量中存储的是值本身，包括String ，Number，Boolean，Undefined，Null")]),t._v(" "),v("p",[t._v("​    复杂数据类型（引用类型）：在存储时变量中存储的仅仅是地址（引用），通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等；")]),t._v(" "),v("h2",{attrs:{id:"_33-css3新特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_33-css3新特性"}},[t._v("#")]),t._v(" 33."),v("strong",[t._v("CSS3新特性：")])]),t._v(" "),v("ol",[v("li",[t._v("颜色：新增RGBA，HSLA模式")]),t._v(" "),v("li",[t._v("文字阴影（text-shadow）")]),t._v(" "),v("li",[t._v("边框： 圆角（border-radius）边框阴影： box-shadow")]),t._v(" "),v("li",[t._v("盒子模型：box-sizing")]),t._v(" "),v("li",[t._v("背景：background-size 设置背景图片的尺寸background-origin 设置背景图片的原点background-clip 设置背景图片的裁切区域，以”，”分隔可以设置多背景，用于自适应布局")]),t._v(" "),v("li",[t._v("渐变：linear-gradient、radial-gradient")]),t._v(" "),v("li",[t._v("过渡：transition，可实现动画")]),t._v(" "),v("li",[t._v("自定义动画")]),t._v(" "),v("li",[t._v("在CSS3中唯一引入的伪元素 ：selection.")]),t._v(" "),v("li",[t._v("媒体查询，多栏布局")]),t._v(" "),v("li",[t._v("border-image")]),t._v(" "),v("li",[t._v("2D转换：transform：translate(x，y) rotate(x，y) skew(x，y) scale(x，y)")]),t._v(" "),v("li",[t._v("3D转换")])]),t._v(" "),v("p",[t._v("14.新增选择器：属性选择器、伪类选择器、伪元素选择器。")]),t._v(" "),v("h2",{attrs:{id:"_34-h5新特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_34-h5新特性"}},[t._v("#")]),t._v(" 34."),v("strong",[t._v("H5新特性:")])]),t._v(" "),v("ol",[v("li",[t._v("拖拽释放(Drag and drop) API")]),t._v(" "),v("li",[t._v("语义化更好的内容标签（header,nav,footer,aside,article,section）")]),t._v(" "),v("li",[t._v("音频、视频API(audio,video)")]),t._v(" "),v("li",[t._v("画布(Canvas) API")]),t._v(" "),v("li",[t._v("地理(Geolocation) API")]),t._v(" "),v("li",[t._v("数据存储 localStorage、sessionStorage")]),t._v(" "),v("li",[t._v("表单控件date、time、email、url、search")])]),t._v(" "),v("h2",{attrs:{id:"_35-什么是响应式设计-响应式设计的基本原理是什么-如何兼容低版本的ie"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_35-什么是响应式设计-响应式设计的基本原理是什么-如何兼容低版本的ie"}},[t._v("#")]),t._v(" 35.什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？")]),t._v(" "),v("p",[t._v("响应式网站设计(Responsive Web design)是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。")]),t._v(" "),v("p",[t._v("基本原理是通过媒体查询检测不同的设备屏幕尺寸做处理。")]),t._v(" "),v("p",[t._v("页面头部必须有meta声明的viewport。")]),t._v(" "),v("h2",{attrs:{id:"_36-before-和-after中双冒号和单冒号有什么区别-解释一下这2个伪元素的作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_36-before-和-after中双冒号和单冒号有什么区别-解释一下这2个伪元素的作用"}},[t._v("#")]),t._v(" 36.::before 和 :after中双冒号和单冒号有什么区别？解释一下这2个伪元素的作用")]),t._v(" "),v("p",[t._v("单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。")]),t._v(" "),v("p",[t._v("::before就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于dom之中，只存在在页面之中。")]),t._v(" "),v("h2",{attrs:{id:"_37-eval是做什么的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_37-eval是做什么的"}},[t._v("#")]),t._v(" "),v("strong",[t._v("37.eval是做什么的？")])]),t._v(" "),v("p",[t._v("它的功能是把对应的字符串解析成JS代码并运行； 　　应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。 　　由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(’(’+ str +’)’)。")]),t._v(" "),v("h2",{attrs:{id:"_38-location对象的属性和方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_38-location对象的属性和方法"}},[t._v("#")]),t._v(" 38.Location对象的属性和方法")]),t._v(" "),v("p",[t._v("属性")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("属性")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("hostname")]),t._v(" "),v("td",[t._v("返回URL的主机名")])]),t._v(" "),v("tr",[v("td",[t._v("port")]),t._v(" "),v("td",[t._v("返回一个URL服务器使用的端口号")])]),t._v(" "),v("tr",[v("td",[t._v("pathname")]),t._v(" "),v("td",[t._v("返回的URL路径名。")])]),t._v(" "),v("tr",[v("td",[t._v("protocol")]),t._v(" "),v("td",[t._v("返回一个URL协议")])]),t._v(" "),v("tr",[v("td",[t._v("hash")]),t._v(" "),v("td",[t._v("返回从井号 (#) 开始的 URL（锚）")])]),t._v(" "),v("tr",[v("td",[t._v("href")]),t._v(" "),v("td",[t._v("返回完整的URL")])]),t._v(" "),v("tr",[v("td",[t._v("search")]),t._v(" "),v("td",[t._v("返回从问号 (?) 开始的 URL（查询部分）")])]),t._v(" "),v("tr",[v("td",[t._v("host")]),t._v(" "),v("td",[t._v("返回一个URL的主机名和端口")])])])]),t._v(" "),v("p",[t._v("方法")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("属性")]),t._v(" "),v("th",[t._v("描述")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("replace()")]),t._v(" "),v("td",[t._v("用新的文档替换当前文档。替换当前页面，不记录历史，不可以后退")])]),t._v(" "),v("tr",[v("td",[t._v("reload()")]),t._v(" "),v("td",[t._v("重新加载当前文档。相当于点击刷新按钮刷新F5，如果参数为true，相当于ctrl+F5强制刷新")])]),t._v(" "),v("tr",[v("td",[t._v("assign()")]),t._v(" "),v("td",[t._v("加载新的文档。跟href一样，可以跳转页面")])])])]),t._v(" "),v("h2",{attrs:{id:"_39-navigator对象是做什么的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_39-navigator对象是做什么的"}},[t._v("#")]),t._v(" 39.Navigator对象是做什么的?")]),t._v(" "),v("p",[t._v("window.navigator 接口表示用户代理的状态和标识。")]),t._v(" "),v("p",[t._v("navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客户机发送服务器的 user-agent 头部的值。")]),t._v(" "),v("p",[t._v("Navigator.onLine网络状态")]),t._v(" "),v("p",[t._v("onLine 属性是一个只读的布尔值，声明了系统是否处于脱机模式，如果系统属于脱机状态，则返回 false，否则返回 true。")]),t._v(" "),v("p",[t._v("HTML5 给我们提供了2个事件  online  和 offline，给window绑定事件--检测网络开始状态")]),t._v(" "),v("h2",{attrs:{id:"_40-history对象的属性和方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_40-history对象的属性和方法"}},[t._v("#")]),t._v(" 40.History对象的属性和方法?")]),t._v(" "),v("p",[t._v("属性")]),t._v(" "),v("p",[t._v("length  返回浏览器历史列表中的 URL 数量。")]),t._v(" "),v("p",[t._v("方法")]),t._v(" "),v("p",[t._v("back()  加载 history 列表中的前一个 URL。")]),t._v(" "),v("p",[t._v("forward()  加载 history 列表中的下一个 URL。")]),t._v(" "),v("p",[t._v("go()  加载 history 列表中的某个具体页面。")]),t._v(" "),v("h2",{attrs:{id:"_41-拖拽api的相关事件"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_41-拖拽api的相关事件"}},[t._v("#")]),t._v(" 41.拖拽API的相关事件")]),t._v(" "),v("p",[v("strong",[t._v("被拖动的源对象可以触发的事件：")])]),t._v(" "),v("p",[t._v("(1)ondragstart：源对象开始被拖动")]),t._v(" "),v("p",[t._v("(2)ondrag：源对象被拖动过程中(鼠标可能在移动也可能未移动)")]),t._v(" "),v("p",[t._v("(3)ondragend：源对象被拖动结束")]),t._v(" "),v("p",[v("strong",[t._v("拖动源对象可以进入到上方的目标对象可以触发的事件：")])]),t._v(" "),v("p",[t._v("(1)ondragenter：目标对象被源对象拖动着进入")]),t._v(" "),v("p",[t._v("(2)ondragover：目标对象被源对象拖动着悬停在上方")]),t._v(" "),v("p",[t._v("(3)ondragleave：源对象拖动着离开了目标对象")]),t._v(" "),v("p",[t._v("(4)ondrop：源对象拖动着在目标对象上方释放/松手")]),t._v(" "),v("p",[t._v("DataTransfer")]),t._v(" "),v("p",[t._v("在进行拖放操作时，"),v("code",[t._v("DataTransfer")]),t._v(" 对象用来保存被拖动的数据。它可以保存一项或多项数据、一种或者多种数据类型")]),t._v(" "),v("h2",{attrs:{id:"_42-在浏览器地址栏键入url-按下回车之后会经历以下流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_42-在浏览器地址栏键入url-按下回车之后会经历以下流程"}},[t._v("#")]),t._v(" 42.在浏览器地址栏键入URL，按下回车之后会经历以下流程：")]),t._v(" "),v("p",[t._v("1、浏览器向 DNS 服务器请求解析该 URL 中的域名所对应的 IP 地址;")]),t._v(" "),v("p",[t._v("2、解析出 IP 地址后，根据该 IP 地址和默认端口")]),t._v(" "),v("p",[t._v("80，和服务器建立TCP连接;")]),t._v(" "),v("p",[t._v("3、浏览器发出读取文件(URL中域名后面部分对应的文件)的HTTP")]),t._v(" "),v("p",[t._v("请求，该请求消息作为 TCP三次握手的第三个报文的数据发送给服务器;")]),t._v(" "),v("p",[t._v("4、服务器对浏览器请求作出响应，并把对应的 html 文本发送给浏览器")]),t._v(" "),v("p",[t._v("5、释放TCP连接;")]),t._v(" "),v("p",[t._v("6、浏览器加载该 html 文本并显示内容;")]),t._v(" "),v("h2",{attrs:{id:"_43-http协议和https协议的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_43-http协议和https协议的区别"}},[t._v("#")]),t._v(" 43.http协议和https协议的区别")]),t._v(" "),v("p",[t._v("一、传输信息安全性不同")]),t._v(" "),v("p",[t._v("1、http协议：是超文本传输协议，信息是明文传输。如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息。")]),t._v(" "),v("p",[t._v("2、https协议：是具有安全性的ssl加密传输协议，为浏览器和服务器之间的通信加密，确保数据传输的安全。")]),t._v(" "),v("p",[t._v("二、连接方式不同")]),t._v(" "),v("p",[t._v("1、http协议：http的连接很简单，是无状态的。2、https协议：是由SSL＋HTTP协议构建的可进行加密传输、身份认证的网络协议。")]),t._v(" "),v("p",[t._v("三、端口不同")]),t._v(" "),v("p",[t._v("1、http协议：使用的端口是80。2、https协议：使用的端口是443．")]),t._v(" "),v("p",[t._v("四、证书申请方式不同")]),t._v(" "),v("p",[t._v("1、http协议：免费申请。2、https协议：需要到ca申请证书，一般免费证书很少，需要交费。")]),t._v(" "),v("h2",{attrs:{id:"_44-http常见状态码有哪些"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_44-http常见状态码有哪些"}},[t._v("#")]),t._v(" 44.http常见状态码有哪些？")]),t._v(" "),v("p",[v("strong",[t._v("一: 2开头状态码")])]),t._v(" "),v("p",[t._v("2xx (成功)表示成功处理了请求的状态代码")]),t._v(" "),v("p",[t._v("200 (成功) 服务器已成功处理了请求。 通常。")]),t._v(" "),v("p",[v("strong",[t._v("二: 3开头状态码")])]),t._v(" "),v("p",[t._v("3xx (重定向) 表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。")]),t._v(" "),v("p",[t._v("304 (未修改) 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。")]),t._v(" "),v("p",[v("strong",[t._v("三: 4开头状态码")])]),t._v(" "),v("p",[t._v("4xx(请求错误) 这些状态代码表示请求可能出错，妨碍了服务器的处理")]),t._v(" "),v("p",[t._v("1:400 (错误请求) 服务器不理解请求的语法。")]),t._v(" "),v("p",[t._v("2:401未授权。")]),t._v(" "),v("p",[t._v("2:403 (禁止) 服务器拒绝请求。")]),t._v(" "),v("p",[t._v("3:404 (未找到) 服务器找不到请求的网页。")]),t._v(" "),v("p",[v("strong",[t._v("四: 5开头状态码")])]),t._v(" "),v("p",[t._v("5xx(服务器错误)这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错")]),t._v(" "),v("p",[t._v("500 (服务器内部错误) 服务器遇到错误，无法完成请求。")]),t._v(" "),v("h2",{attrs:{id:"_45-get和post的区别-何时使用post"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_45-get和post的区别-何时使用post"}},[t._v("#")]),t._v(" 45.GET和POST的区别，何时使用POST？")]),t._v(" "),v("p",[t._v("1.GET：一般用于信息获取，使用地址栏提交参数;而Post是通过提交请求体提交参数。")]),t._v(" "),v("p",[t._v("2.GET：对所发送信息的数量也有限制, 传送的数据量较小，不能大于2KB。post 传送的数据量较大。")]),t._v(" "),v("p",[t._v("3.GET:是从服务器上获取数据，post 是向服务器传送数据,一般用于修改服务器上的资源。")]),t._v(" "),v("p",[t._v("在以下情况中，请使用 POST 请求：")]),t._v(" "),v("p",[t._v("无法使用缓存文件（更新服务器上的文件或数据库），")]),t._v(" "),v("p",[t._v("向服务器发送大量数据，")]),t._v(" "),v("p",[t._v("发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠。")]),t._v(" "),v("h2",{attrs:{id:"_46-json是什么-json和javascript普通对象有什么区别-如何把js对象转化为json字符串-又如何把json字符串转化为javascript对象"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_46-json是什么-json和javascript普通对象有什么区别-如何把js对象转化为json字符串-又如何把json字符串转化为javascript对象"}},[t._v("#")]),t._v(" 46.JSON是什么？JSON和JavaScript普通对象有什么区别？如何把JS对象转化为JSON字符串，又如何把JSON字符串转化为JavaScript对象？")]),t._v(" "),v("ul",[v("li",[t._v("JSON （JavaScript Object Notation）一种简单的数据格式，比xml更轻巧。JSON的规则很简单： 对象是一个无序的“名称/值”对集合。一个对象以“{”（左括号）开始，“}”（右括号）结束。每个“名称”后跟一个“:”（冒号）；“名称/值”对之间使用“,”（逗号）分隔。 它是一种严格的js对象的格式，JSON的属性名必须有双引号，如果值是字符串，也必须是双引号；")]),t._v(" "),v("li",[t._v("Javascript 普通对象:一种javascript的引用类型, 可允许加单引号，双引号")]),t._v(" "),v("li",[v("strong",[t._v("JSON.stringify()")]),t._v(" 和 **JSON.parse()**相互转换.")])]),t._v(" "),v("h2",{attrs:{id:"_47-什么是ajax-ajax作用是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_47-什么是ajax-ajax作用是什么"}},[t._v("#")]),t._v(" 47.什么是ajax？ajax作用是什么？")]),t._v(" "),v("p",[t._v("AJAX = 异步 JavaScript 和 XML。 "),v("strong",[t._v("AJAX 是一种用于创建快速动态网页的技术")]),t._v("。 通过在后台与服务器进行少量数据交换,AJAX 可以使网页实现异步更新.")]),t._v(" "),v("h2",{attrs:{id:"_48-为什么要用ajax"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_48-为什么要用ajax"}},[t._v("#")]),t._v(" 48.为什么要用ajax?")]),t._v(" "),v("p",[t._v("ajax应用程序的优势在于：")]),t._v(" "),v("ol",[v("li",[t._v("通过异步模式，提升了用户体验")]),t._v(" "),v("li",[t._v("优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用")]),t._v(" "),v("li",[t._v("Ajax引擎在客户端运行，承担了一部分本来由服务器承担的工作，从而减少了大用户量下的服务器负载。")])]),t._v(" "),v("h2",{attrs:{id:"_49-ajax最大的特点是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_49-ajax最大的特点是什么"}},[t._v("#")]),t._v(" 49.ajax最大的特点是什么?")]),t._v(" "),v("p",[t._v("Ajax可以实现动态不刷新（局部刷新） 就是能在不更新整个页面的前提下维护数据。这使得Web应用程序更为迅捷地回应用户动作，并避免了在网络上发送那些没有改变过的信息。")]),t._v(" "),v("h2",{attrs:{id:"_50-请介绍一下xmlhttprequest对象。"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_50-请介绍一下xmlhttprequest对象。"}},[t._v("#")]),t._v(" 50.请介绍一下XMLHttprequest对象。")]),t._v(" "),v("p",[t._v("Ajax的核心是JavaScript对象XmlHttpRequest。该对象在Internet Explorer 5中首次引入，它是一种支持异步请求的技术。简而言之，XmlHttpRequest使您可以使用JavaScript向服务器提出请求并处理响应，而不阻塞用户。通过XMLHttpRequest对象，Web开发人员可以在页面加载以后进行页面的局部更新。")]),t._v(" "),v("h2",{attrs:{id:"_51-ajax几种请求方式-他们的优缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_51-ajax几种请求方式-他们的优缺点"}},[t._v("#")]),t._v(" 51.ajax几种请求方式？他们的优缺点？")]),t._v(" "),v("p",[t._v("常用的post,get,delete put")]),t._v(" "),v("ul",[v("li",[v("strong",[t._v("代码上的区别")]),t._v("\n1:get通过url传递参数。\n2:post参数在请求体中,发送ajax请求时post设置请求头 ,规定请求数据类型。")]),t._v(" "),v("li",[v("strong",[t._v("使用上的区别")]),t._v("\n1:post比get安全\n(因为post参数在请求体中。get参数在url上面)\n2:get传输速度比post快 根据传参决定的。\n(post通过请求体传参，后台通过数据流接收。速度稍微慢一些。而get通过url传参可以直接获取)。\n3:post传输文件大理论没有限制 ,get传输文件小大概7-8k,ie中时4k左右。\n4:get一般用于获取数据,post上传数据(上传的数据比较多, 而且上传数据都是重要数据。所以不论在安全性还是数据量级post是最好的选择)。")])]),t._v(" "),v("h2",{attrs:{id:"_52-ajax都有哪些优点和缺点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_52-ajax都有哪些优点和缺点"}},[t._v("#")]),t._v(" 52.ajax都有哪些优点和缺点？")]),t._v(" "),v("ul",[v("li",[t._v("ajax的优点\n1、最大的一点是页面无刷新，用户的体验非常好。\n2、使用异步方式与服务器通信，具有更加迅速的响应能力。\n3、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。\n4、基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。")]),t._v(" "),v("li",[t._v("ajax的缺点\n1、ajax不支持浏览器back按钮。\n2、安全问题 AJAX暴露了与服务器交互的细节。\n3、对搜索引擎的支持比较弱。\n4、破坏了程序的异常机制。\n5、不容易调试。")])]),t._v(" "),v("h2",{attrs:{id:"_53-原生js-ajax请求有几个步骤-分别是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_53-原生js-ajax请求有几个步骤-分别是什么"}},[t._v("#")]),t._v(" 53.原生js ajax请求有几个步骤？分别是什么?")]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('//创建 XMLHttpRequest 对象\nvar ajax = new XMLHttpRequest();\n//规定请求的类型、URL 以及是否异步处理请求。\najax.open(\'GET\',url,true);\n//发送信息至服务器时内容编码类型\najax.setRequestHeader("Content-type", "application/x-www-form-urlencoded"); \n//发送请求\najax.send(null);  \n//接受服务器响应数据\najax.onreadystatechange = function () {\n    if (obj.readyState == 4 && (obj.status == 200 || obj.status == 304)) { \n    }\n}\n')])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br"),v("span",{staticClass:"line-number"},[t._v("7")]),v("br"),v("span",{staticClass:"line-number"},[t._v("8")]),v("br"),v("span",{staticClass:"line-number"},[t._v("9")]),v("br"),v("span",{staticClass:"line-number"},[t._v("10")]),v("br"),v("span",{staticClass:"line-number"},[t._v("11")]),v("br"),v("span",{staticClass:"line-number"},[t._v("12")]),v("br"),v("span",{staticClass:"line-number"},[t._v("13")]),v("br")])]),v("h2",{attrs:{id:"_54-什么是跨域-如何解决跨域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_54-什么是跨域-如何解决跨域"}},[t._v("#")]),t._v(" 54.什么是跨域？ 如何解决跨域？")]),t._v(" "),v("p",[t._v("要说跨域,首先得说同源策略,")]),t._v(" "),v("p",[t._v("1、同源策略,是浏览器的安全策略,协议名、域名、端口号必须完全一致。")]),t._v(" "),v("p",[t._v("2、跨域是违背同源策略就会产生跨域。")]),t._v(" "),v("p",[t._v("3、解决跨域")]),t._v(" "),v("ul",[v("li",[t._v("vue代理配置、nginx代理配置、后端设置、jsonp（前后端配合）")])]),t._v(" "),v("p",[t._v("然后介绍自己在项目中是如何去做的")]),t._v(" "),v("h2",{attrs:{id:"_55-说一下网络四层模型"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_55-说一下网络四层模型"}},[t._v("#")]),t._v(" 55.说一下网络四层模型")]),t._v(" "),v("p",[t._v("1、主机到网络层")]),t._v(" "),v("p",[t._v("实际上TCP/IP参考模型没有真正描述这一层的实现，只是要求能够提供给其上层-网络互连层一个访问接口，以便在其上传递IP分组。由于这一层次未被定义，所以其具体的实现方法将随着网络类型的不同而不同。")]),t._v(" "),v("p",[t._v("2、网络互连层")]),t._v(" "),v("p",[t._v("网络互连层是整个TCP/IP协议栈的核心。它的功能是把分组发往目标网络或主机。同时，为了尽快地发送分组，可能需要沿不同的路径同时进行分组传递。因此，分组到达的顺序和发送的顺序可能不同，这就需要上层必须对分组进行排序。")]),t._v(" "),v("p",[t._v("网络互连层定义了分组格式和协议，即IP协议（Internet Protocol）。")]),t._v(" "),v("p",[t._v("网络互连层除了需要完成路由的功能外，也可以完成将不同类型的网络（异构网）互连的任务。除此之外，网络互连层还需要完成拥塞控制的功能。")]),t._v(" "),v("p",[t._v("3、传输层")]),t._v(" "),v("p",[t._v("在TCP/IP模型中，传输层的功能是使源端主机和目标端主机上的对等实体可以进行会话。在传输层定义了两种服务质量不同的协议。即：传输控制协议TCP（transmission control protocol）和用户数据报协议UDP（user datagram protocol）。")]),t._v(" "),v("p",[t._v("TCP协议是一个面向连接的、可靠的协议。它将一台主机发出的字节流无差错地发往互联网上的其他主机。在发送端，它负责把上层传送下来的字节流分成报文段并传递给下层。在接收端，它负责把收到的报文进行重组后递交给上层。TCP协议还要处理端到端的流量控制，以避免缓慢接收的接收方没有足够的缓冲区接收发送方发送的大量数据。")]),t._v(" "),v("p",[t._v("UDP协议是一个不可靠的、无连接协议，主要适用于不需要对报文进行排序和流量控制的场合。")]),t._v(" "),v("p",[t._v("4、应用层")]),t._v(" "),v("p",[t._v("TCP/IP模型将OSI参考模型中的会话层和表示层的功能合并到应用层实现。")]),t._v(" "),v("p",[t._v("应用层面向不同的网络应用引入了不同的应用层协议。其中，有基于TCP协议的，如文件传输协议（File Transfer Protocol，FTP）、虚拟终端协议（TELNET）、超文本传输协议（Hyper Text Transfer Protocol，HTTP），也有基于UDP协议的。")]),t._v(" "),v("h2",{attrs:{id:"_56-什么是jsonp-原理是什么-缺点是什么"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_56-什么是jsonp-原理是什么-缺点是什么"}},[t._v("#")]),t._v(" 56.什么是Jsonp?原理是什么,缺点是什么?")]),t._v(" "),v("p",[t._v('1、Jsonp(JSON with Padding) 是 json 的一种"使用模式"，可以让网页从别的域名（网站）那获取资料，即跨域读取数据。')]),t._v(" "),v("p",[t._v("2、Jsonp的原理:利用script标签可以获取不同源资源的特点，来达到跨域访问某个资源的目的。")]),t._v(" "),v("p",[t._v("3、为什么不是真正的 ajax?")]),t._v(" "),v("p",[t._v("​     ajax的核心是 ： 通过XmlHttpRequest获取非本页内容，")]),t._v(" "),v("p",[t._v("​     Jsonp的核心 ： 动态添加"),v("script")])])}),[],!1,null,null,null);_.default=s.exports}}]);